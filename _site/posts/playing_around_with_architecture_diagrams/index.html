
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/output.css">
    <link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/lightfair.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/plantuml.min.js"></script>
    <title>Playing with PlantUML</title>
  </head>
  <body>
  <div class="min-h-screen bg-white">
    <div class="p-8">
      <h1 class="text-2xl p-0">The Learning Corner</h1>
    </div>
    <hr class="text-stone-200">
    
<div class="max-w-[800px] px-5 sm:px-8 py-4">
  <h1 class="text-2xl font-bold pb-4">Playing with PlantUML</h1>
  
    <div class="text-sm pb-4">March 9, 2025</div>
  
  <div class="markdown">
  <p>I'm trying to understand some of the following: Nginx, networking, docker
networks, TLS, Client Server communication, server to server communication..
Playing around with PlantUML might help with that. It also has the nice side effect
of giving me some practice with PlantUML.</p>

<div class="plantuml-container" id="plantuml-1744841580045-295">
  <div class="tabs">
    <button class="tab-button active" data-tab="image-plantuml-1744841580045-295">Image</button>
    <button class="tab-button" data-tab="code-plantuml-1744841580045-295">Code</button>
  </div>
  <div class="tab-content" data-tab-content="image-plantuml-1744841580045-295">
    <img src="/posts/playing_around_with_architecture_diagrams/playing_around_with_architecture_diagrams_001.png" alt="PlantUML Diagram">
  </div>
  <div class="tab-content hidden" data-tab-content="code-plantuml-1744841580045-295">
    <pre><code>@startuml
skinparam componentStyle rectangle
rectangle Server {
rectangle Nginx {
component "Backend"
component "Keycloak"
}
}
rectangle "Public Internet" as public_internet
[Browser] -&gt; [Backend] : request
[Browser] --&gt; [Keycloak] : authenticate
[Backend] --&gt; public_internet
public_internet --&gt; [Keycloak] : userinfo
note left of public_internet
I need to send the request to
keycloak via the public internet
because I do not have
internal TLS set up
in my docker network
end note
@enduml</code></pre>
  </div>
</div>
<script>
  (function() {
    const container = document.getElementById('plantuml-1744841580045-295');
    const buttons = container.querySelectorAll('.tab-button');
    const contents = container.querySelectorAll('.tab-content');

    buttons.forEach(button => {
      button.addEventListener('click', () => {
        const tab = button.dataset.tab;
        buttons.forEach(btn => btn.classList.remove('active'));
        contents.forEach(content => content.classList.add('hidden'));
        button.classList.add('active');
        container.querySelector('.tab-content[data-tab-content="' + tab + '"]').classList.remove('hidden');
      });
    });
  })();
</script>

<p>I learned that Nginx does not encrypt the packet as it is shown below. Instead
a TLS handshake is carried out between the Backend (which is the client in this case) and Keycloak, which
acts as the server. For this the client initiates a connection request to the server.</p>
<p>After completing the TCP handshake, the TLS handshake is carried out. This
involves the server sending its certificate. The certificate contains the
public key.</p>
<p>It just so happens that in this special case the certificate is the
same one that the backend also uses when requests are made to it.</p>
<p>The client in this case encrypts a pre-master secret with the servers public key and
sends it to the server. I guess this constitutes a key exchange. We have the
classic scenario here, where asymmetric encryption is used for the key
exchange, and afterwards the encryption is symmetric with the master key which
was generated by the client.</p>
<p>To recap: The client uses the servers public key which was sent within the
certificate. This public key is used by the client to encrypt a pre-master
secret which it has just generated. This means that at this point only the
client knows the pre-master secret. After it has been encrypted even the client
cannot decrypt it again. For this the private key would be necessary. The
server has the private key. This private key and the public key constitutes a
key pair. So when the server receives the encrypted pre-master secret, it can
decrypt it.</p>
<p>The client and the server, each on its own will use the decrypted pre-master
secret to derive a master secret. For this, previously exchanged random numbers
are used.</p>
<p>The below diagram will have to be updated with this new found understanding.</p>

<div class="plantuml-container" id="plantuml-1744841581166-566">
  <div class="tabs">
    <button class="tab-button active" data-tab="image-plantuml-1744841581166-566">Image</button>
    <button class="tab-button" data-tab="code-plantuml-1744841581166-566">Code</button>
  </div>
  <div class="tab-content" data-tab-content="image-plantuml-1744841581166-566">
    <img src="/posts/playing_around_with_architecture_diagrams/playing_around_with_architecture_diagrams_002.png" alt="PlantUML Diagram">
  </div>
  <div class="tab-content hidden" data-tab-content="code-plantuml-1744841581166-566">
    <pre><code>@startuml
!pragma teoz true
skinparam BoxPadding 5
skinparam ParticipantPadding 5
participant "Public Internet" order 50
Browser -&gt; Nginx : GET api/cart
note left Nginx: Nginx terminates TLS
Nginx -&gt; Backend ++ : proxy_pass :3000
Backend -&gt; Nginx : GET realm/userinfo
note left Backend: Initiate encrypted transfer
Nginx -&gt; "Public Internet" : GET realm/userinfo
"Public Internet" --&gt; Nginx : :443
Nginx -&gt; Keycloak ++ : proxy_pass :8080
Keycloak --&gt; Nginx -- : userinfo
Nginx -&gt; "Public Internet" : 168.290.592.104
"Public Internet" --&gt; Nginx
Nginx -&gt; Backend : proxy_pass :3000
Backend -&gt; Backend : authenticate
Backend --&gt; Nginx --
Nginx --&gt; Browser : response
box "Server" #c1cde6
box "Docker Network"
participant Nginx
participant Backend
participant Keycloak
end box
end box
@enduml</code></pre>
  </div>
</div>
<script>
  (function() {
    const container = document.getElementById('plantuml-1744841581166-566');
    const buttons = container.querySelectorAll('.tab-button');
    const contents = container.querySelectorAll('.tab-content');

    buttons.forEach(button => {
      button.addEventListener('click', () => {
        const tab = button.dataset.tab;
        buttons.forEach(btn => btn.classList.remove('active'));
        contents.forEach(content => content.classList.add('hidden'));
        button.classList.add('active');
        container.querySelector('.tab-content[data-tab-content="' + tab + '"]').classList.remove('hidden');
      });
    });
  })();
</script>

<p>One issue I have with creating plantUML diagrams is that I build them in my
notes directory - separate from my blog - and copy the images over when done.
This is a bit of a hassle and needs to be optimized. Thus I will put my
plantUML code right into the blog posts. I will write some logic which checks
for the <code>@startuml</code> and <code>@enduml</code> tags. When these show up, I will have a tab
section where the viewer can toggle between the code and the image. And because
I am lazy and I have other things to do, I'll let Gemini do that for me.</p>
<p>Let's see how it does:</p>

<div class="plantuml-container" id="plantuml-1744841582688-401">
  <div class="tabs">
    <button class="tab-button active" data-tab="image-plantuml-1744841582688-401">Image</button>
    <button class="tab-button" data-tab="code-plantuml-1744841582688-401">Code</button>
  </div>
  <div class="tab-content" data-tab-content="image-plantuml-1744841582688-401">
    <img src="/posts/playing_around_with_architecture_diagrams/playing_around_with_architecture_diagrams_004.png" alt="PlantUML Diagram">
  </div>
  <div class="tab-content hidden" data-tab-content="code-plantuml-1744841582688-401">
    <pre><code>@startuml

Alice -&gt; Bob : does it work?
Bob --&gt; Alice : we'll see...

Charline -&gt; Bob : this works pretty good!
Bob --&gt; Charline : That's right!

@enduml
</code></pre>
  </div>
</div>
<script>
  (function() {
    const container = document.getElementById('plantuml-1744841582688-401');
    const buttons = container.querySelectorAll('.tab-button');
    const contents = container.querySelectorAll('.tab-content');

    buttons.forEach(button => {
      button.addEventListener('click', () => {
        const tab = button.dataset.tab;
        buttons.forEach(btn => btn.classList.remove('active'));
        contents.forEach(content => content.classList.add('hidden'));
        button.classList.add('active');
        container.querySelector('.tab-content[data-tab-content="' + tab + '"]').classList.remove('hidden');
      });
    });
  })();
</script>

<p>Let me put another UML Diagram right here:</p>

<div class="plantuml-container" id="plantuml-1744841582034-702">
  <div class="tabs">
    <button class="tab-button active" data-tab="image-plantuml-1744841582034-702">Image</button>
    <button class="tab-button" data-tab="code-plantuml-1744841582034-702">Code</button>
  </div>
  <div class="tab-content" data-tab-content="image-plantuml-1744841582034-702">
    <img src="/posts/playing_around_with_architecture_diagrams/playing_around_with_architecture_diagrams_003.png" alt="PlantUML Diagram">
  </div>
  <div class="tab-content hidden" data-tab-content="code-plantuml-1744841582034-702">
    <pre><code>@startuml
[component1] --&gt; [componentX]
[component1] --&gt; [component2]
[component2] -&gt; [component3]
@enduml</code></pre>
  </div>
</div>
<script>
  (function() {
    const container = document.getElementById('plantuml-1744841582034-702');
    const buttons = container.querySelectorAll('.tab-button');
    const contents = container.querySelectorAll('.tab-content');

    buttons.forEach(button => {
      button.addEventListener('click', () => {
        const tab = button.dataset.tab;
        buttons.forEach(btn => btn.classList.remove('active'));
        contents.forEach(content => content.classList.add('hidden'));
        button.classList.add('active');
        container.querySelector('.tab-content[data-tab-content="' + tab + '"]').classList.remove('hidden');
      });
    });
  })();
</script>

<p>Now I have a concrete use case for a plantUML diagram relating to this blog.
Currently, the transform code which parses each blog post and checks whether it
can find plantUML code blocks will create an image for each code block it
finds, every time something changes - anywhere in the code. This is a problem.
My output folder gets spammed with all these duplicate images. Also, if a
diagram actually changes, the old version of the image will just stay there.</p>
<p>A first point of consideration would be that the image generation shouldn't run<br>
on any change in the code base.</p>
<p>Second I need to figure out how to delete old versions when the diagram code
changed.</p>
<p>The goal is to have only one image for each diagram in a post at any given time.</p>
<p>Let's draw it up:</p>

<div class="plantuml-container" id="plantuml-1744841583400-640">
  <div class="tabs">
    <button class="tab-button active" data-tab="image-plantuml-1744841583400-640">Image</button>
    <button class="tab-button" data-tab="code-plantuml-1744841583400-640">Code</button>
  </div>
  <div class="tab-content" data-tab-content="image-plantuml-1744841583400-640">
    <img src="/posts/playing_around_with_architecture_diagrams/playing_around_with_architecture_diagrams_005.png" alt="PlantUML Diagram">
  </div>
  <div class="tab-content hidden" data-tab-content="code-plantuml-1744841583400-640">
    <pre><code>@startuml

skinparam componentStyle rectangle

component markdown
rectangle {
    component "11ty" as 11ty
    component "PlantUml Transform" as transform
    note top of transform
        Iterate over uml blocks
        and append index 
        to output file
    end note
}
component "plantUml Image" as png
actor user 

user -&gt; markdown : changes and saves
11ty --&gt; markdown : registers change and builds
11ty -&gt; transform 
transform -&gt; png : creates

@enduml
</code></pre>
  </div>
</div>
<script>
  (function() {
    const container = document.getElementById('plantuml-1744841583400-640');
    const buttons = container.querySelectorAll('.tab-button');
    const contents = container.querySelectorAll('.tab-content');

    buttons.forEach(button => {
      button.addEventListener('click', () => {
        const tab = button.dataset.tab;
        buttons.forEach(btn => btn.classList.remove('active'));
        contents.forEach(content => content.classList.add('hidden'));
        button.classList.add('active');
        container.querySelector('.tab-content[data-tab-content="' + tab + '"]').classList.remove('hidden');
      });
    });
  })();
</script>

<p>For the file names of the generated PNGs I use the same convention as plantUML
does. This means that when I manually run plantUML, it will just update the
existing images instead of creating new ones.</p>
<p>Turns out my reasoning above was flawed. I don't even have the problem of
having to delete old versions of the images. I just override the one image file
I create initially.</p>
<p>So now as I researched the markdown capabilities in 11ty, I came across
syntax highlighting. Let's test it out with an example of the code
used for the transform.</p>
<pre><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUmlBlocks</span>(<span class="hljs-params">content</span>) {
  <span class="hljs-comment">// these are blocks which are directly in the markdown content</span>
  <span class="hljs-keyword">const</span> umlBlockRegex = <span class="hljs-regexp">/^&lt;p&gt;@startuml&lt;\/p&gt;\n(?:.*\n)+?^&lt;p&gt;@enduml&lt;\/p&gt;$/gm</span>;
  <span class="hljs-comment">// these are blocks enclosed in ```plantuml code blocks</span>
  <span class="hljs-keyword">const</span> codeBlockPlantumlRegex = <span class="hljs-regexp">/^&lt;pre&gt;&lt;code class=&quot;language-plantuml&quot;&gt;@startuml\n(?:.*\n)+?^@enduml\n&lt;\/code&gt;&lt;\/pre&gt;$/gm</span>;

  <span class="hljs-keyword">const</span> umlBlocks = content.<span class="hljs-title function_">match</span>(umlBlockRegex);
  <span class="hljs-keyword">const</span> codeBlocks = content.<span class="hljs-title function_">match</span>(codeBlockPlantumlRegex);
  <span class="hljs-keyword">if</span> (!umlBlocks) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">const</span> allPlantUmlBlocks = umlBlocks.<span class="hljs-title function_">concat</span>(codeBlocks);
  <span class="hljs-keyword">return</span> allPlantUmlBlocks;
}
</code></pre>

  </div>
</div>

  </div>
  </body>
</html>
